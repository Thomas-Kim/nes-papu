Start of our report.

--------------Thomas' Section-----------------
The noise and triangle channels had some interesting features in the original NES, some of which were deemed superfluous for this project and replaced by better alternatives.

The noise channel uses a 1-bit RNG to generate a random square wave whose volume is determined by a memory mapped input-only register. Following the specification of the NES random number generator, an initial configuration for a 15-bit shift register is chosen based on register input. Additionally, an extra timer (divider) is set by register input, allowing adjustable frequencies. Every timer period, the least significant bit of the shift register is consumed as RNG output, bits 1-14 are shifted right, and the new value of bit 14 is determined by taking the XOR of shift[//TODO

The triangle channel, in the original NES, uses a different method of counting length than the other channels. However, the reason this is done does not appear to be to provide any additional functionality, instead it may simply be a hardware limitation which required a separate unit for the triangle unit. For this project, the regular length counter was used to control the triangle channel length.

Unlike the other channels, the triangle channel does not have adjustable volume. For the original NES, the triangle channel's volume can be adjusted by taking advantage of a side effect - the PCM channel volume has an inversely proportional relationship to the triangle channel volume, so playing a silent digital sound at a high volume will reduce the triangle channel volume. This behavior was not implemented, as the specifics are not well-documented and likely unintentional http://skrasoft.com/blog/?p=190. This method of adjusting volume is widely known but not widely used in NES games.
----------------------------------------------

Side notes:
The specifications laid down in the different resources we used were different (with respect to, for example, the table values for the length counter) based on which documents we checked. We ended up switching to those detailed at http://wiki.nesdev.com/w/index.php/APU_Length_Counter because they were more reasonable (in terms of beats and such) for attempting to reason about the music produced.
We did still notice, however, that our notes were not lasting as long as we were expecting them to, so we ran some debugging steps on our divided clock, to determine whether or not it were successfully producing a satisfactorily slowed clock rate (1.79mhz -> 60 hz). Anyways, we had had our clocks switched, so we fixed that and left behind an ~1hz LED (LED4) for you to enjoy alongside your music.

Overarching Notes
>>Discuss how we borrowed code from the SAMPLE DUDE,
>>Discuss how we changed the clock to be the same as the NES clock w/ the clock_pll,
>>Discuss the resources (references) we used to determine the specs of our stuff,
>>Discuss how we only had one 16-bit DAC, instead of multiple smaller DACs and (more specialized hardware) mixing.

Specifics:
>>Square Wave
>>Triangle wave
	>>Discuss how you get different pitches by sampling faster with the same triangle! :P
>>Noise channel
	>>Woo random numbers :P
>>DCM (if we get it)
	>>Discuss how this would be controlled in the code somewhat
	>>Talk about how using this in an actual game (a lot) would require slowing the play due to memory accesses (each read paused CPU for 4 cycles), is stored as sequence of 1-bit deltas.
>>Wave combinor / DAC
	>>Specific equations used-- didn't use theirs, exactly; used our own, based on the max values and such
	>>Still used a lookup table, but scaled the values from 16'h0000 -> 16'hffff instead of 0.0 -> 1.0 (did so in C code, produced the table).
	>>Note that this is a 16-bit shindig, BUT the NES would have only 8-bit audio (I believe)... Anyways, on the NES, I believe this mixing was done with hardware (analog hardware), which is why the (rough) scaling here was 0->1 in the equations we were using.
	>>Didn't respect the variation amoung the diff wave types (triangle, noise, dcm) exactly. Still would be non-linear scaling, I believe.